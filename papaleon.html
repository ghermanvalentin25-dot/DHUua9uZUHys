<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roblox Model Viewer (HTML)</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--muted:#94a3b8;--accent:#7dd3fc}
    html,body{height:100%}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071029 0%, #081226 100%);color:#e6eef8}
    .app{display:grid;grid-template-columns:320px 1fr;gap:16px;height:100vh;padding:18px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    header{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    .title{font-weight:700;font-size:16px}
    input[type=text]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{background:transparent;border:1px solid rgba(125,211,252,0.12);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
    .sidebar{display:flex;flex-direction:column;height:calc(100vh - 96px)}
    .tree{overflow:auto;padding:8px;margin-top:8px}
    .node{padding:6px 8px;border-radius:8px;cursor:pointer;margin-bottom:4px}
    .node:hover{background:rgba(125,211,252,0.04)}
    .node.selected{background:linear-gradient(90deg,rgba(125,211,252,0.06),rgba(125,211,252,0.02));box-shadow:inset 0 0 0 1px rgba(125,211,252,0.03)}
    .details{height:calc(100vh - 36px);display:flex;flex-direction:column}
    .details-top{display:flex;gap:12px;align-items:center}
    .pane{flex:1;overflow:auto;padding:12px}
    .props table{width:100%;border-collapse:collapse}
    .props th{color:var(--muted);text-align:left;padding:6px 4px;font-weight:600}
    .props td{padding:6px 4px;border-top:1px dashed rgba(255,255,255,0.02)}
    pre{white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,0.25);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);overflow:auto}
    .controls{display:flex;gap:8px;align-items:center}
    .small{font-size:13px;color:var(--muted)}
    .meta{font-size:12px;color:var(--muted);margin-top:6px}
    .flex{display:flex;gap:8px}
    .hidden{display:none}
    .search{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    .footer{font-size:12px;color:var(--muted);padding-top:8px}
  </style>
</head>
<body>
  <div class="app">
    <div class="card sidebar">
      <header>
        <div>
          <div class="title">Roblox Model Viewer</div>
          <div class="small">Paste a Model ID or upload an .rbxmx/.rbxmd file</div>
        </div>
      </header>

      <div style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center">
        <input id="modelId" type="text" placeholder="Enter model id (e.g. 123456789)" />
        <button id="fetchBtn">Fetch</button>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <input id="fileInput" type="file" accept=".rbxmx,.rbxmd,.xml" />
        <button id="clearBtn">Clear</button>
      </div>

      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <input id="searchTree" class="search" placeholder="Search tree" />
      </div>

      <div class="tree card" id="treeRoot" style="margin-top:8px"></div>

      <div class="footer">Tip: CORS may block direct Roblox asset fetch. If fetch fails, upload the .rbxmx file you exported from Roblox Studio.</div>
    </div>

    <div class="card details">
      <div class="details-top">
        <div style="flex:1">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h2 id="selectedTitle">No selection</h2>
            <div class="controls">
              <button id="downloadXml" class="hidden">Download XML</button>
              <button id="copyBtn" class="hidden">Copy</button>
            </div>
          </div>
          <div id="meta" class="meta"></div>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:360px 1fr;gap:12px;padding-top:12px;flex:1">
        <div class="pane props">
          <h3>Properties</h3>
          <div id="propsArea"><div class="small">Select an instance to view its properties.</div></div>
        </div>

        <div class="pane">
          <h3>Content</h3>
          <div id="contentArea"><div class="small">Code, animation IDs or extra data will show here when you select an instance.</div></div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const modelIdInput = document.getElementById('modelId');
  const fetchBtn = document.getElementById('fetchBtn');
  const fileInput = document.getElementById('fileInput');
  const treeRoot = document.getElementById('treeRoot');
  const propsArea = document.getElementById('propsArea');
  const contentArea = document.getElementById('contentArea');
  const selectedTitle = document.getElementById('selectedTitle');
  const meta = document.getElementById('meta');
  const downloadXml = document.getElementById('downloadXml');
  const copyBtn = document.getElementById('copyBtn');
  const clearBtn = document.getElementById('clearBtn');
  const searchTree = document.getElementById('searchTree');

  let parsed = null; // root object from parse
  let xmlText = '';
  let selectedNode = null;

  function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

  async function fetchModel(id){
    // Try Roblox assetdelivery endpoint (may be CORS-blocked)
    const urls = [
      `https://assetdelivery.roblox.com/v1/asset?id=${id}`,
      `https://www.roblox.com/asset/?id=${id}`,
      `https://assetgame.roblox.com/asset/?id=${id}`
    ];
    let lastErr = null;
    for(const u of urls){
      try{
        const res = await fetch(u);
        if(!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        // try read as text
        const text = await blob.text();
        if(text && text.trim().startsWith('<')){
          return text;
        }
        // sometimes it's a binary format (rbxmx zipped?) - treat as failure
        lastErr = 'Not XML or binary format returned';
      }catch(err){ lastErr = err; }
    }
    throw new Error('Failed to fetch model (CORS or non-XML). ' + lastErr);
  }

  function parseRbxmx(xmlStr){
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlStr, 'application/xml');
    const parseError = doc.querySelector('parsererror');
    if(parseError) throw new Error('XML parse error');

    // Roblox rbxmx structure: <roblox> ... <Item class="Model" referent="..."> ... <Item class="Part" ...> ... </roblox>
    // We'll collect all Item nodes and map by referent, and also find top-level Instances by Parent relations
    const items = Array.from(doc.querySelectorAll('Item'));
    const map = new Map();
    items.forEach(it=>{
      const ref = it.getAttribute('referent') || null;
      const cls = it.getAttribute('class') || it.getAttribute('class');
      const nameNode = it.querySelector('Properties > string[name="Name"]');
      const name = nameNode ? nameNode.textContent : (it.getAttribute('name')|| it.getAttribute('class'));
      // collect properties
      const props = {};
      const propNodes = Array.from(it.querySelectorAll('Properties > *'));
      propNodes.forEach(pn=>{
        const propName = pn.getAttribute('name');
        if(!propName) return;
        // For script source, there might be <ProtectedString> or <string>
        props[propName] = pn.textContent;
        // if property is an <Content> type with id attribute
        if(pn.tagName === 'Content') props[propName] = pn.getAttribute('id') || pn.textContent;
      });
      map.set(ref, {ref, class:cls, name, props, itemNode: it});
    });

    // Build parent-child relations using 'Parent' property which contains referent like 'RBX1234;'
    function resolveParent(item){
      const parentRaw = item.props['Parent'];
      if(!parentRaw) return null;
      // parentRaw might be like "RBX..." or have qualifiers; try to match referent keys
      // Many rbxmx use the referent itself in Parent tag (e.g. 'RBX...'). We'll attempt to find matching map key.
      // map keys often include 'RBX' prefix; attempt direct match, else search items for matching name.
      const key = parentRaw.trim();
      if(map.has(key)) return map.get(key);
      // try variants
      for(const [k,v] of map.entries()){
        if(k && k.includes(key)) return v;
      }
      return null;
    }

    // create node objects
    const nodes = [];
    map.forEach(v=>nodes.push(Object.assign({},v, {children:[]})));

    // index by referent
    const idx = new Map(nodes.map(n=>[n.ref,n]));

    // attach children
    nodes.forEach(n=>{
      const parent = resolveParent(n) || null;
      if(parent && idx.has(parent.ref)){
        idx.get(parent.ref).children.push(n);
      }
    });

    // roots = nodes with no parent
    const roots = nodes.filter(n=>{
      const parent = resolveParent(n);
      return !parent;
    });

    return {doc, map:idx, roots, rawXml: xmlStr};
  }

  function renderTree(treeNodes, container, filter){
    container.innerHTML = '';
    function walk(node, depth=0){
      const el = document.createElement('div');
      el.className = 'node';
      el.style.paddingLeft = (8 + depth*12) + 'px';
      el.textContent = `${node.class} â€” ${node.name || '(no name)'}`;
      el.dataset.ref = node.ref;
      el.addEventListener('click', e=>{
        e.stopPropagation();
        document.querySelectorAll('.node').forEach(n=>n.classList.remove('selected'));
        el.classList.add('selected');
        selectNode(node);
      });
      container.appendChild(el);
      if(node.children && node.children.length){
        node.children.forEach(c=>{
          if(!filter || (c.name && c.name.toLowerCase().includes(filter)) || (c.class && c.class.toLowerCase().includes(filter))){
            walk(c, depth+1);
          } else {
            // still render if any descendant matches
            if(hasDescendantMatch(c, filter)) walk(c, depth+1);
          }
        });
      }
    }
    function hasDescendantMatch(n, f){
      if(!f) return true;
      if((n.name && n.name.toLowerCase().includes(f)) || (n.class && n.class.toLowerCase().includes(f))) return true;
      if(!n.children) return false;
      return n.children.some(ch=>hasDescendantMatch(ch,f));
    }

    treeNodes.forEach(n=>{ if(!filter || hasDescendantMatch(n, filter)) walk(n,0); });
  }

  function selectNode(node){
    selectedNode = node;
    selectedTitle.textContent = `${node.class} â€” ${node.name || '(no name)'}`;
    meta.textContent = (node.ref ? 'Referent: '+node.ref : '') + (node.props && node.props['Name']? ' â€¢ Name property: '+node.props['Name'] : '');

    // render properties
    const keys = Object.keys(node.props||{}).sort();
    if(keys.length===0) propsArea.innerHTML = '<div class="small">No properties</div>';
    else{
      const rows = ['<table>','<thead><tr><th>Property</th><th>Value</th></tr></thead>','<tbody>'];
      keys.forEach(k=>{
        const v = node.props[k];
        rows.push(`<tr><td><strong>${escapeHtml(k)}</strong></td><td>${escapeHtml(String(v||''))}</td></tr>`);
      });
      rows.push('</tbody></table>');
      propsArea.innerHTML = rows.join('\n');
    }

    // render content: scripts / animation / source
    contentArea.innerHTML = '';
    copyBtn.classList.add('hidden');

    // detect scripts
    const scriptClasses = ['Script','LocalScript','ModuleScript'];
    if(scriptClasses.includes(node.class)){
      // try to find Source or ProtectedString
      const source = node.props['Source'] || node.props['ProtectedString'] || node.itemNode.querySelector('Properties > ProtectedString')?.textContent || node.itemNode.querySelector('Properties > string[name="Source"]')?.textContent || node.itemNode.querySelector('Properties > ProtectedString[name="Source"]')?.textContent;
      if(source){
        const pre = document.createElement('pre');
        pre.textContent = source;
        contentArea.appendChild(pre);
        copyBtn.classList.remove('hidden');
        copyBtn.onclick = ()=>navigator.clipboard.writeText(source).then(()=>alert('Copied'));
        return;
      }
    }

    // detect animation
    if(node.class === 'Animation' || node.props['AnimationId']){
      const aid = node.props['AnimationId'] || node.props['Id'] || node.props['Animation'];
      contentArea.innerHTML = `<div class="small">Animation detected</div><pre>${escapeHtml(String(aid||'Unknown'))}</pre>`;
      return;
    }

    // detect ModuleScript with Source in child properties
    if(node.class === 'ModuleScript' && node.itemNode){
      const p = node.itemNode.querySelector('Properties > ProtectedString') || node.itemNode.querySelector('Properties > string[name="Source"]');
      if(p){ contentArea.innerHTML = `<pre>${escapeHtml(p.textContent)}</pre>`; copyBtn.classList.remove('hidden'); copyBtn.onclick = ()=>navigator.clipboard.writeText(p.textContent).then(()=>alert('Copied')); return; }
    }

    // generic: show XML of the item
    const serializer = new XMLSerializer();
    const xml = serializer.serializeToString(node.itemNode);
    const pre = document.createElement('pre'); pre.textContent = xml;
    contentArea.appendChild(pre);
  }

  async function loadAndParseXml(text){
    xmlText = text;
    try{
      parsed = parseRbxmx(text);
      renderTree(parsed.roots, treeRoot);
      downloadXml.classList.remove('hidden');
      downloadXml.onclick = ()=>{
        const blob = new Blob([xmlText], {type:'application/xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'model.rbxmx'; a.click(); URL.revokeObjectURL(url);
      }
    }catch(err){
      alert('Failed to parse XML: '+err.message);
    }
  }

  fetchBtn.addEventListener('click', async ()=>{
    const id = modelIdInput.value.trim();
    if(!id) return alert('Enter a model ID');
    fetchBtn.disabled = true; fetchBtn.textContent = 'Fetching...';
    try{
      const xml = await fetchModel(id);
      await loadAndParseXml(xml);
    }catch(err){
      alert('Fetch error: '+err.message + '\n\nTip: if this fails because of CORS, download .rbxmx from Roblox Studio and use "Upload file".');
    }finally{ fetchBtn.disabled = false; fetchBtn.textContent = 'Fetch'; }
  });

  fileInput.addEventListener('change', async e=>{
    const f = e.target.files[0];
    if(!f) return;
    const text = await f.text();
    await loadAndParseXml(text);
  });

  clearBtn.addEventListener('click', ()=>{
    modelIdInput.value=''; fileInput.value=''; treeRoot.innerHTML=''; propsArea.innerHTML='<div class="small">Select an instance to view its properties.</div>'; contentArea.innerHTML='<div class="small">Code, animation IDs or extra data will show here when you select an instance.</div>'; selectedTitle.textContent='No selection'; meta.textContent=''; downloadXml.classList.add('hidden'); copyBtn.classList.add('hidden'); parsed = null; xmlText='';
  });

  searchTree.addEventListener('input', ()=>{
    const q = searchTree.value.trim().toLowerCase();
    if(parsed) renderTree(parsed.roots, treeRoot, q);
  });

  // initial small demo hint
  treeRoot.innerHTML = '<div class="small">Tree will appear here after you fetch a model or upload an .rbxmx file.</div>';

})();
</script>
</body>
</html>